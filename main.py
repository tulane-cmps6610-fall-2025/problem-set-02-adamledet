# -*- coding: utf-8 -*-
"""main

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zIi0gsjg4JS5A9Wfbm0Xpnv3ZUvqnnXU
"""

"""
Adam Ledet
CMPS 6610  Problem Set 2
See problemset-02.pdf for details.
"""
import time
from tabulate import tabulate

class BinaryNumber:
    """ done """
    def __init__(self, n):
        self.decimal_val = n
        self.binary_vec = list('{0:b}'.format(n))

    def __repr__(self):
        return('decimal=%d binary=%s' % (self.decimal_val, ''.join(self.binary_vec)))


## Implement multiplication functions here. Note that you will have to
## ensure that x, y are appropriately sized binary vectors for a
## divide and conquer approach.

# some useful utility functions to manipulate bit vectors
def binary2int(binary_vec):
    if len(binary_vec) == 0:
        return BinaryNumber(0)
    return BinaryNumber(int(''.join(binary_vec), 2))

def split_number(vec):
    return (binary2int(vec[:len(vec)//2]),
            binary2int(vec[len(vec)//2:]))

def bit_shift(number, n):
    return binary2int(number.binary_vec + ['0'] * n)

def pad(x,y):
    # pad with leading 0 if x/y have different number of bits
    if len(x) < len(y):
        x = ['0'] * (len(y)-len(x)) + x
    elif len(y) < len(x):
        y = ['0'] * (len(x)-len(y)) + y
    # pad with leading 0 if not even number of bits
    if len(x) % 2 != 0:
        x = ['0'] + x
        y = ['0'] + y
    return x,y

def quadratic_multiply(x, y):
    listX = list(str(x))
    listY = list(str(y))
    currentNum = []
    counter = 0
    #print("x: ", x)
    #print("y: ", y)
    for i in range(len(listX)):
      for j in range(len(listY)):
        currentNum.append(int(listX[len(listX)-i-1])*int(listY[len(listY)-j-1])*(10**i)*(10**j))
        '''print("----- ",counter," -----")
        print("int(listX[len(listX)-i]) ", int(listX[len(listX)-i-1]))
        print("int(listY[len(listY)-j]) ", int(listY[len(listY)-j-1]))
        print("i) ", 10**i)
        print("j) ", 10**j)
        print(currentNum[counter])
        counter+=1'''
    return sum(currentNum)
    ###

def subquadratic_multiply(x, y):
    listX = list(str(x))
    listY = list(str(y))
    #print("x: ", x)
    #print("y: ", y)

    if(len(listX)>2 and len(listY) > 3):
      listXa = listX[:-3]
      #print("listXa: ", listXa)
      listXb = listX[-3:]
      #print("listXb: ", listXb)
      listYa = listY[:-3]
      #print("listYa: ", listYa)
      listYb = listY[-3:]
      #print("listYb: ", listYb)
    else:
      #print("RETURN")
      return(quadratic_multiply(x,y))

    #Attributes
    z0 = subquadratic_multiply(int("".join(listXb)),int("".join(listYb)))
    #print("z0: ", z0)
    z2 = subquadratic_multiply(int("".join(listXa)),int("".join(listYa)))
    #print("z2: ", z2)
    z1 = (subquadratic_multiply((int("".join(listXa))+int("".join(listXb))),(int("".join(listYa)))+int("".join(listYb))))-z2-z0
    #print("z1: ", z1)

    result = z2*((10**3)**2) + z1*(10**3) + z0
    return result

    '''if(len(listX) == 1 and len(list(y)==1)):
      return(x*y)
    if(len(listX)>1 and len(listY)==1):
      #SPLIT X AND NOT Y
    if(len(listX)==1 and len(listY)>1):
      #SPLIT Y AND NOT X
    if(len(listX)>1 and len(listY)>1):
      #SPLIT BOTH'''
    '''return("Xa: ", listXa,
           "Xb: ", listXb,
           "Ya: ", listYa,
           "Yb: ", listYb)'''
    ###

## Feel free to add your own tests here.
def test_multiply():
    assert binary2int(quadratic_multiply(BinaryNumber(2), BinaryNumber(2))) == 2*2

# some timing functions here that will make comparisons easy
def time_multiply(x, y, f):
    start = time.time()
    # multiply two numbers x, y using function f
    f(x,y)
    return (time.time() - start)*1000

def compare_multiply():
    res = []
    for n in [10,100,1000,10000,100000,1000000,10000000,100000000,1000000000]:
        qtime = time_multiply(BinaryNumber(n), BinaryNumber(n), quadratic_multiply)
        subqtime = time_multiply(BinaryNumber(n), BinaryNumber(n), subquadratic_multiply)
        res.append((n, qtime, subqtime))
    print_results(res)


def print_results(results):
    print("\n")
    print(
        tabulate(
            results,
            headers=['n', 'quadratic', 'subquadratic'],
            floatfmt=".3f",
            tablefmt="github"))

print("Answer: ",quadratic_multiply(25,13452))

print(subquadratic_multiply(12345,6789))

res = []
for n in [10,100,1000,10000,100000,1000000,10000000,100000000,1000000000]:
    qtime = time_multiply((n), (n), quadratic_multiply)
    subqtime = time_multiply((n), (n), subquadratic_multiply)
    res.append((n, qtime, subqtime))
print_results(res)